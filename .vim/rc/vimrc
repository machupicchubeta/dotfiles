" Make vim more useful
if &compatible
  set nocompatible
endif

" source_rc {{{
function! s:source_rc(path, ...) abort
  let use_global = get(a:000, 0, !has('vim_starting'))
  let abspath = resolve(expand('~/.vim/rc/' . a:path))
  if !use_global
    execute 'source' fnameescape(abspath)
    return
  endif

  " substitute all 'set' to 'setglobal'
  let content = map(readfile(abspath),
        \ 'substitute(v:val, "^\\W*\\zsset\\ze\\W", "setglobal", "")')
  " create tempfile and source the tempfile
  let tempfile = tempname()
  try
    call writefile(content, tempfile)
    execute printf('source %s', fnameescape(tempfile))
  finally
    if filereadable(tempfile)
      call delete(tempfile)
    endif
  endtry
endfunction
" }}}

" Define augroup {{{
augroup MyAutoCmd
  autocmd!
augroup END
" }}}

if has('vim_starting')
  call s:source_rc('init.rc.vim')
endif

call s:source_rc('encoding.rc.vim')

call s:source_rc('edit.rc.vim')

call s:source_rc('view.rc.vim')

" call s:source_rc('filetype.rc.vim')

" filetype {{{
autocmd MyAutoCmd FileType,Syntax,BufNewFile,BufNew,BufRead
      \ * call s:my_on_filetype()
function! s:my_on_filetype() abort "{{{
  if &l:filetype == '' && bufname('%') == ''
    return
  endif

  redir => filetype_out
  silent! filetype
  redir END
  if filetype_out =~# 'OFF'
    " Lazy loading
    silent! filetype plugin indent on
    syntax enable
    filetype detect
  endif
endfunction "}}}
call s:my_on_filetype()
" }}}

call s:source_rc('mappings.rc.vim')

if has('nvim')
  call s:source_rc('neovim.rc.vim')
endif

if IsMac()
  call s:source_rc('unix.rc.vim')
end

call s:source_rc('plug.rc.vim')

if !has('nvim')
  " Allow cursor keys in insert mode
  set esckeys
endif

" Add the g flag to search/replace by default
set gdefault

" Highlight current line
set cursorline
set cursorcolumn

" Highlight IdeographicSpace
function! IdeographicSpace()
  highlight IdeographicSpace term=underline ctermbg=DarkGreen guibg=DarkGreen
endfunction
augroup IdeographicSpace
  autocmd!
  autocmd ColorScheme * call IdeographicSpace()
  autocmd VimEnter,WinEnter,BufRead * let w:m1=matchadd('IdeographicSpace', '　')
augroup END
call IdeographicSpace()

" search {{{
" Highlight searches
set hlsearch

" Ignore case of searches
set ignorecase

" If the search pattern contains upper case characters, override ignorecase option.
set smartcase

" Highlight dynamically as pattern is typed
set incsearch

" Searches wrap around the end of the file.
set wrapscan
" }}}

" Enable mouse in all modes
set mouse=a

" Show the cursor position
set ruler

" Show the current mode
set showmode

" Use relative line numbers
if exists("&relativenumber")
 set relativenumber
 au BufReadPost * set relativenumber
endif

" Start scrolling three lines before the horizontal window border
set scrolloff=3

set pastetoggle=<C-E>

" diff {{{
" Display diff with the file.
command! -nargs=1 -complete=file Diff vertical diffsplit <args>
" Disable diff mode.
command! -nargs=0 Undiff setlocal nodiff noscrollbind wrapscan
" }}}

" Use English help file
set helplang& helplang=en,ja

" Default home directory
let t:cwd = getcwd()

set secure

" emmet {{{
let g:user_emmet_install_global = 0
autocmd FileType html,css EmmetInstall
" }}}

" quickrun key-mapping
silent! nmap <unique> <Space>r <Plug>(quickrun)

" vim-rspec {{{
map <Leader>t :call RunCurrentSpecFile()<CR>
map <Leader>s :call RunNearestSpec()<CR>
map <Leader>l :call RunLastSpec()<CR>
map <Leader>a :call RunAllSpecs()<CR>
" }}}

" vim-submode
call submode#enter_with('bufmove', 'n', '', 's>', '<C-w>>')
call submode#enter_with('bufmove', 'n', '', 's<', '<C-w><')
call submode#enter_with('bufmove', 'n', '', 's+', '<C-w>+')
call submode#enter_with('bufmove', 'n', '', 's-', '<C-w>-')
call submode#map('bufmove', 'n', '', '>', '<C-w>>')
call submode#map('bufmove', 'n', '', '<', '<C-w><')
call submode#map('bufmove', 'n', '', '+', '<C-w>+')
call submode#map('bufmove', 'n', '', '-', '<C-w>-')

" showmarks
let g:showmarks_include='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

" lightline {{{
let g:lightline = {
        \ 'colorscheme': 'solarized',
        \ 'mode_map': {'c': 'NORMAL'},
        \ 'active': {
        \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ], [ 'ale' ] ]
        \ },
        \ 'component_function': {
        \   'modified': 'LightlineModified',
        \   'readonly': 'LightlineReadonly',
        \   'fugitive': 'LightlineFugitive',
        \   'filename': 'LightlineFilename',
        \   'fileformat': 'LightlineFileformat',
        \   'filetype': 'LightlineFiletype',
        \   'fileencoding': 'LightlineFileencoding',
        \   'mode': 'LightlineMode',
        \   'ale': 'LightLineALEStatus'
        \ }
        \ }

function! LightlineModified()
  return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! LightlineReadonly()
  return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? 'x' : ''
endfunction

function! LightlineFilename()
  return ('' != LightlineReadonly() ? LightlineReadonly() . ' ' : '') .
        \ (&ft == 'vimfiler' ? vimfiler#get_status_string() :
        \  &ft == 'vimshell' ? vimshell#get_status_string() :
        \ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
        \ ('' != LightlineModified() ? ' ' . LightlineModified() : '')
endfunction

function! LightlineFugitive()
  try
    if &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
      return fugitive#head()
    endif
  catch
  endtry
  return ''
endfunction

function! LightlineFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! LightlineFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! LightlineFileencoding()
  return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! LightlineMode()
  return winwidth(0) > 60 ? lightline#mode() : ''
endfunction

function! LightLineALEStatus()
  return exists('*ALEGetStatusLine') ? ALEGetStatusLine() : ''
endfunction
" }}}

" smartchr {{{
" function! s:EnableSmartchrBasic()
"   inoremap <buffer><expr> + smartchr#one_of(' + ', '+', '++')
"   inoremap <buffer><expr> & smartchr#one_of(' & ', ' && ', '&')
"   inoremap <buffer><expr> , smartchr#one_of(', ', ',')
"   inoremap <buffer><expr> <Bar> smartchr#one_of('<Bar>', ' <Bar><Bar> ', '<Bar><Bar>')
"   inoremap <buffer><expr> = search('\(&\<bar><bar>\<bar>+\<bar>-\<bar>/\<bar>>\<bar><\) \%#', 'bcn')? '<bs>= ' : search('\(\*\<bar>!\)\%#')? '= ' : smartchr#one_of(' = ', ' == ', ' === ', '=')
" endfunction

function! s:EnableSmartchrRegExp()
  inoremap <buffer><expr> ~ search('\(!\<bar>=\) \%#', 'bcn')? '<bs>~ ' : '~'
endfunction

function! s:EnableSmartchrRubyHash()
  inoremap <buffer><expr> > smartchr#one_of('>', ' => ')
endfunction

function! s:EnableSmartchrHaml()
  call s:EnableSmartchrRubyHash()
  inoremap <buffer> [ []<Esc>i
  inoremap <buffer> { {}<Esc>i
endfunction

function! s:EnableSmartchrCoffeeFunction()
  inoremap <buffer><expr> > smartchr#one_of('>', ' ->')
endfunction

" autocmd FileType c,cpp,php,python,javascript,ruby,coffee,vim call s:EnableSmartchrBasic()
autocmd FileType python,ruby,coffee,vim call s:EnableSmartchrRegExp()
autocmd FileType ruby call s:EnableSmartchrRubyHash()
autocmd FileType haml call s:EnableSmartchrHaml()
autocmd FileType coffee call s:EnableSmartchrCoffeeFunction()
" }}}

" toggle.vim {{{
imap <silent><C-C> <Plug>ToggleI
nmap <silent><C-C> <Plug>ToggleN
vmap <silent><C-C> <Plug>ToggleV

let g:toggle_pairs = {
  \'and':'or',
  \'or':'and',
  \'if':'unless',
  \'unless':'if',
  \'elsif':'else',
  \'else':'elsif',
  \'it':'specify',
  \'specify':'it',
  \'describe':"context",
  \'context':"describe",
  \'true':'false',
  \'false':'true',
  \'yes':'no',
  \'no':'yes',
  \'on':'off',
  \'off':'on',
  \'public':'protected',
  \'protected':'private',
  \'private':'public',
  \'&&':'||',
  \'||':'&&'
\}
" }}}

" solarized
set background=dark
let g:solarized_termcolors=256
let g:solarized_termtrans=1
let g:solarized_visibility = "high"
let g:solarized_contrast = "high"
colorscheme solarized
"if &term =~ "xterm-256color" || "screen-256color"
"  set t_Co=256
"  set t_Sf=[3%dm
"  set t_Sb=[4%dm
"elseif &term =~ "xterm-color"
"  set t_Co=8
"  set t_Sf=[3%dm
"  set t_Sb=[4%dm
"endif

let g:rails_gem_projections = {
            \ "factory_bot": {
            \   "spec/factories/*.rb": {
            \     "command": "factory",
            \     "template": "FactoryBot.define do\n  factory :%s do\n  end\nend",
            \     "alternate": "app/models/%s.rb",
            \     "related": "db/schema.rb#%p",
            \     "affinity": "model"
            \   }
            \ },
            \ "carrierwave": {
            \   "app/uploaders/*_uploader.rb": {
            \     "command": "uploader",
            \     "template": "module %SUploader < CarrierWave::Uploader::Base\nend",
            \     "affinity": "model",
            \     "test": "spec/uploaders/%s_uploader_spec.rb"
            \   }
            \ },
            \ "decorator": {
            \   "app/decorators/*_decorator.rb": {
            \     "command": "decorator",
            \     "template": "module %SDecorator\nend",
            \     "related": "app/models/%s.rb",
            \     "affinity": "model",
            \     "test": "spec/decorators/%s_decorator_spec.rb"
            \   }
            \ },
            \ "sidekiq": {
            \   "app/workers/*_worker.rb": {
            \     "command": "worker",
            \     "template": "class %SWorker\n  include Sidekiq::Worker\n\n  def perform()\n  end\nend",
            \     "related": "app/models/%s.rb",
            \     "affinity": "model",
            \     "test": "spec/decorators/%s_decorator_spec.rb"
            \   }
            \ }}

let g:rails_projections = {
            \ "app/batches/*.rb": {
            \   "command": "batch",
            \   "template": "class %S\nend",
            \   "test": "spec/batches/%s_spec.rb"
            \ },
            \ "app/controllers/concerns/*.rb": {
            \   "command": "controllerconcern",
            \   "template": "module %S\nend",
            \   "test": "spec/controllers/concerns/%s_spec.rb"
            \ },
            \ "app/models/concerns/*.rb": {
            \   "command": "modelconcern",
            \   "template": "module %S\nend",
            \   "test": "spec/models/concerns/%s_spec.rb"
            \ }}

" vim-indent-guides
let g:indent_guides_enable_on_vim_startup = 1
let g:indent_guides_enable_on_vim_startup = 1
let g:indent_guides_start_level = 2
let g:indent_guides_guide_size = 2
let g:indent_guides_exclude_filetypes = ['help', 'tagbar']

" vim-fugitive
autocmd QuickFixCmdPost *grep* cwindow
set statusline+=%{fugitive#statusline()}

" Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
vmap <Enter> <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)

" neocomplete.vim {{{
if !has('nvim')
  " Disable AutoComplPop.
  let g:acp_enableAtStartup = 1
  " Use neocomplete.
  let g:neocomplete#enable_at_startup = 1
  " Use smartcase.
  let g:neocomplete#enable_smart_case = 1
  " Set minimum syntax keyword length.
  let g:neocomplete#sources#syntax#min_keyword_length = 3
  let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

  " Define dictionary.
  let g:neocomplete#sources#dictionary#dictionaries = {
      \ 'default' : '',
      \ 'vimshell' : $HOME.'/.vimshell_hist',
      \ 'scheme' : $HOME.'/.gosh_completions'
          \ }

  " Define keyword.
  if !exists('g:neocomplete#keyword_patterns')
      let g:neocomplete#keyword_patterns = {}
  endif
  let g:neocomplete#keyword_patterns['default'] = '\h\w*'

  " Plugin key-mappings.
  inoremap <expr><C-g>     neocomplete#undo_completion()
  inoremap <expr><C-l>     neocomplete#complete_common_string()

  " Recommended key-mappings.
  " <CR>: close popup and save indent.
  " inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
  " function! s:my_cr_function()
  "   return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
  "   " For no inserting <CR> key.
  "   "return pumvisible() ? "\<C-y>" : "\<CR>"
  " endfunction
  " <TAB>: completion.
  " inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
  " <C-h>, <BS>: close popup and delete backword char.
  " inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
  " inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
  " Close popup by <Space>.
  "inoremap <expr><Space> pumvisible() ? "\<C-y>" : "\<Space>"

  " AutoComplPop like behavior.
  "let g:neocomplete#enable_auto_select = 1

  " Shell like behavior(not recommended).
  "set completeopt+=longest
  "let g:neocomplete#enable_auto_select = 1
  "let g:neocomplete#disable_auto_complete = 1
  "inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

  " Enable omni completion.
  autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
  autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
  autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
  autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
  autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

  " Enable heavy omni completion.
  if !exists('g:neocomplete#sources#omni#input_patterns')
    let g:neocomplete#sources#omni#input_patterns = {}
  endif
  let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
  let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
  let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
  let g:neocomplete#sources#omni#input_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'

  if !exists('g:neocomplete#force_omni_input_patterns')
    let g:neocomplete#force_omni_input_patterns = {}
  endif
  let g:neocomplete#force_omni_input_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'

  " Disable completion in gitcommit
  if !exists('g:neocomplete#text_mode_filetypes')
    let g:neocomplete#tags_filter_patterns = {}
    let g:neocomplete#text_mode_filetypes = {}
  endif
  let g:neocomplete#text_mode_filetypes.gitcommit = 0
endif
" }}}

" tags {{{
set tags=./tags;,$HOME/.vim/tags;
" }}}

" deoplete {{{
if has('nvim')
  let g:deoplete#enable_at_startup = 1
  let g:deoplete#omni#input_patterns = {}
  let g:deoplete#omni#input_patterns.ruby = ['[^. *\t]\.\w*', '[a-zA-Z_]\w*::']
endif
" }}}

" open-browser {{{
  nmap ;o <Plug>(openbrowser-open)
  vmap ;o <Plug>(openbrowser-open)
  nmap ;s <Plug>(openbrowser-search)
" }}}

" operator-replace
xmap p <Plug>(operator-replace)

" operator-surround
nmap <silent>sa <Plug>(operator-surround-append)a
nmap <silent>sd <Plug>(operator-surround-delete)a
nmap <silent>sr <Plug>(operator-surround-replace)a
nmap <silent>sc <Plug>(operator-surround-replace)a

" matchit
source $VIMRUNTIME/macros/matchit.vim

" reek.vim
let g:reek_on_loading = 1
let g:reek_always_show = 1
let g:reek_line_limit = 1000

" ale
let g:ale_sign_column_always = 1
nmap <silent> <C-k> <Plug>(ale_previous_wrap)
nmap <silent> <C-j> <Plug>(ale_next_wrap)
let g:ale_set_loclist = 0
let g:ale_set_quickfix = 1
" let g:ale_open_list = 1
" let g:ale_keep_list_window_open = 1
let g:ale_echo_msg_format = '[%linter%] %s'
let g:ale_statusline_format = ['ALE ± %d', 'ALE ✭ %d', 'ALE ♥']

" vim-javascript
let g:javascript_plugin_flow = 1

" javascript-libraries-syntax
let g:used_javascript_libs = 'jquery,react,flux,vue'
autocmd FileType javascript,javascript.jsx let b:javascript_lib_use_jquery = 1
autocmd FileType javascript,javascript.jsx let b:javascript_lib_use_react = 1
autocmd FileType javascript,javascript.jsx let b:javascript_lib_use_flux = 1
autocmd FileType javascript,javascript.jsx let b:javascript_lib_use_vue = 1

" delimitMate
let delimitMate_quotes = "\" '"
